---
title: Three-node Example in the Method paper
author: Written by Xiao Yang, peer-reviewed by
date: Fall, 2017 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{3-node-example}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


### Overview
This is to illustrate the conceptualization of psychological network, we introduce a three-node network. We created an R package named "pompom" (person-oriented modeling and perturbation on the model) (for manual and details see XXX), and we will use the functions in "pompom" to conduct analysis in this tutorial. 

Note: please install this package before running the code in this tutorial. 


### Components of Tutorial
This tutorial is arrnaged in the order of actual analysis, and it will be slightly different from the manuscript (cite XXX)

1. Network Graph based on temporal relations
2. Estimation of uSEM model
3. Impulse response analysis and time profiles plot
4. Computation of impulse response analysis metric (iRAM)


Explain the 3-node example:
The 3-node network is a hypothetical example used for the purpose of illustration. As explained in the paper, the variables in time-series data (e.g. experience sampling data) are nodes in the network terminology and network graph, and the temporal relations are edges. 

Our hypohetical 3-node newtork was using simulated data based on a pre-defined temporal relationship matrix and noise level. The temporal relationship is as follows, and noise level is at .1.

We simulated 200 occasions to represent 200 repeated measurements of the three variables in the real studies. 



### Step 0. Import the libraries required for this tutorial and simulate time-series.
```{r, message = FALSE, warning = FALSE}
library(pompom)
library(ggplot2)
library(qgraph)
library(MASS)
require(reshape2)
set.seed(1234)
```


#### Set up a 3 node model

```{r}

n.obs <- 200 # number of observation
p <- 3 # number of variables
noise.level <- 0.1
psi <- cbind(rnorm(n.obs,0, noise.level), 
             rnorm(n.obs,0, noise.level), 
             rnorm(n.obs,0, noise.level)) # 3 time-series of noise for 3 variables

true.beta <-  matrix(c(0,0,0,0,0,0,
                       0,0,0,0,0,0,
                       0,0,0,0,0,0,
                       0.2,0,0.25,0,0,0.6, 
                       0,0.3,0,-0.2,0,-0.6, 
                       0,-0.2,0.3,0,0,0), 
                     nrow = 2 * p, 
                     ncol = 2 * p, 
                     byrow = TRUE)

contemporaneous.relations <- matrix(true.beta[(p+1):(2*p),(p+1):(2*p)], nrow = p, ncol = p, byrow = F)
lag.1.relations <- matrix(true.beta[(p+1):(2*p),1:p], nrow = p, ncol = p, byrow = F)

```


True model is: 
```{r}
true.beta
```


#### Network graph
To introduce the terminologies of networks, each of the 3 variables is depicted as a node (circle), and the temporal relations among the nodes are depicted as edges (arrows, and the arrow indicate directionality of the temporal relationship), with color indicating sign of relation (green = positive, red = negative), thickness indicating strength of relation, and line shape indicating temporality of the association (dashed = lag-1, solid = contemporaneous). Lag-1 relations mean the temporal relations between variables from measurement t -1 to the measurement t, and contemporaneous relations means the temporal relations between variables within the same measurement.

```{r, fig.width = 8, fig.height =6}
plot_network_graph(true.beta, p)
```


#### Simulate time-series
some explaination (equation of simulation?)

```{r}
time.series <- matrix(rep(0, p * n.obs), nrow = n.obs, ncol = p)
time.series[1,] <- rnorm(p,0,1)

row <- p
for (row in 2:n.obs)
{
  time.series[row,] <- solve(diag(1,p, p) - contemporaneous.relations) %*% lag.1.relations %*% time.series[row-1,] +
    solve(diag(1,p, p) - contemporaneous.relations) %*% psi[row, ]
}
time.series <- data.frame(time.series)
names(time.series) <- c("happy", "sad", "other.communion")
```


#### Plot time-series 

```{r, fig.width = 8, fig.height =6}
time.series$time <- seq(1,length(time.series[,1]),1)

time.series.long <- melt(time.series, id="time")  ## convert to long format

ggplot(data=time.series.long,
       aes(x=time, y=value, colour=variable)) +
  geom_line() + 
  facet_wrap( ~ variable  , nrow = p * 2) +
  scale_y_continuous(breaks = seq(0, 100, by = 50)) + 
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank(),
    strip.text.y = element_blank(),
    axis.text.y = element_text(), 
    axis.title.y = element_blank()
    )+
  ylim(-1,1)
time.series$time <- NULL
```




### Step 2. Apply unified Structural Equation Modeling (uSEM) on time-series data. 

#### Use uSEM to fit the model and parse parameters. 
```{r, fig.width = 8, fig.height =6}
library(lavaan)
var.number <- p # number of variables
lag.order <- 1 # lag order of the model

model.fit <- uSEM(var.number, time.series, lag.order, verbose = FALSE, trim = TRUE) # trim indicates whether the final model trimmed all insignificant temporal relations
beta.matrix <- parse.beta(p, model.fit, 1, matrix = TRUE) # parse temporal relations in matrix format
plot_network_graph(beta.matrix$est, var.number)
```

estimated beta0 = 
```{r}
beta.matrix$est
beta.matrix$se
```


### Step 3. Impulse response analysis

#### Set parameters
```{r}
steps <- 100 # number of steps to generate time profile 
replication <- 200 # number of repilcations in bootstrap 
threshold <- .01 # setting threshold for approximate asymptote (iRAM calculation)
```


#### Point estimation of iRAM.
```{r, fig.width = 8, fig.height =6, warning = F}
# ponit estimate of iRAM 
point.estimate.iRAM <- iRAM(model.fit, beta = NULL, var.number, lag.order, boot = F)

point.estimate.iRAM$recovery.time 
# point.estimate.iRAM$time.series.data
```

Plot time profile

```{r, fig.width = 8, fig.height =6, warning = F}
plot_time_profile(point.estimate.iRAM$time.series.data, threshold = threshold, xupper = 50)

```

#### Bootstraped iRAM.

```{r}

bootstrap.iRAM <- iRAM(model.fit, 
                       beta = NULL, 
                       var.number, 
                       lag.order,
                       threshold = threshold,
                       boot = TRUE, 
                       replication = replication,
                       steps= steps
                       # ,
                       # plot_time_profile = TRUE,
                       # plot.histogram = TRUE
                       )

bootstrap.iRAM$mean
bootstrap.iRAM$upper
bootstrap.iRAM$lower
# bootstrap.iRAM$time.profile.data
# bootstrap.iRAM$recovery.time.reps
```

Plot boostrapped time profiles
need to output the bootstrapped time profiles data
```{r, fig.width = 8, fig.height =6, warning = F}
plot_time_profile(bootstrap.iRAM$time.profile.data, threshold = threshold, xupper = 25)
# plot_time_profile(bootstrap.iRAM$time.profile.data, threshold = threshold, xupper = 25)

```


Plot boostrapped iRAM distribution
need to output the bootstrapped recovery time data
```{r, fig.width = 8, fig.height =6, warning = F}
plot_iRAM_dist(bootstrap.iRAM$recovery.time.reps)

```


### check accuracy of iRAM estimation
```{r}
# change iRAM into taking beta.matrix as a parameter, so that you can use iRAM to calculate
true.iRAM <- iRAM(model.fit= NULL,
                  true.beta,
                  var.number, 
                  lag.order, 
                  boot = F)


sum.diff <- 0
for (row in 1:nrow(true.iRAM$recovery.time))
{
  sum.diff <- sum.diff + (bootstrap.iRAM$recovery.time.reps[row,] -
    c(true.iRAM$recovery.time[1,], 
      true.iRAM$recovery.time[2,], 
      true.iRAM$recovery.time[3,]))^2
}
RMSE <- sqrt(sum.diff/nrow(true.iRAM$recovery.time))


sum.diff <- 0
for (row in 1:nrow(true.iRAM$recovery.time))
{
  sum.diff <- sum.diff + (bootstrap.iRAM$recovery.time.reps[row,] -
    c(true.iRAM$recovery.time[1,], 
      true.iRAM$recovery.time[2,], 
      true.iRAM$recovery.time[3,]))/
    (c(true.iRAM$recovery.time[1,], 
      true.iRAM$recovery.time[2,], 
      true.iRAM$recovery.time[3,]))
}
RB <- 1/nrow(true.iRAM$recovery.time) * sum.diff

SD <- NULL
for (col in 1:(var.number^2))
{
  SD <- cbind(SD, sd(bootstrap.iRAM$recovery.time.reps[,col]))
}

  
  
# metrics
true.iRAM$recovery.time # true value
bootstrap.iRAM$mean # estimated mean
RMSE
RB
SD 



```
